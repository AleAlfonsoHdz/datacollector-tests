# Copyright 2017 StreamSets Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
import string
import pytest

from streamsets.testframework.markers import elasticsearch, sdc_min_version
from streamsets.testframework.utils import get_random_string

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


@elasticsearch
@sdc_min_version('3.0.0.0') # stop_after_first_batch
def test_elasticsearch_pipeline_errors(sdc_builder, sdc_executor, elasticsearch):
    """Test for a pipeline's error records being pumped to Elasticsearch. We do so by making a Dev Raw Data source
    target to Error stage which would send records to the pipeline configured Elasticsearch error records handling.
    We then assert the error records what we find in Elasticsearch. The pipeline would look like:

    Elasticsearch error pipeline:
        dev_raw_data_source >> error_target
    """
    # Test static
    es_index = get_random_string(string.ascii_letters, 10).lower()  # Elasticsearch indexes must be lower case
    es_mapping = get_random_string(string.ascii_letters, 10)
    es_doc_id = get_random_string(string.ascii_letters, 10)
    raw_str = 'Hello World!'

    # Build pipeline
    builder = sdc_builder.get_pipeline_builder()
    errstg = builder.add_error_stage('Write to Elasticsearch')
    errstg.set_attributes(document_id=es_doc_id, index=es_index, mapping=es_mapping)
    dev_raw_data_source = builder.add_stage('Dev Raw Data Source').set_attributes(data_format='TEXT',
                                                                                  stop_after_first_batch=True,
                                                                                  raw_data=raw_str)
    error_target = builder.add_stage('To Error')

    dev_raw_data_source >> error_target
    es_error_pipeline = builder.build().configure_for_environment(elasticsearch)
    sdc_executor.add_pipeline(es_error_pipeline)

    try:
        elasticsearch.client.create_index(es_index)

        # Run pipeline and read from Elasticsearch to assert
        sdc_executor.start_pipeline(es_error_pipeline).wait_for_finished()

        responses = elasticsearch.client.search(es_index)
        assert len(responses) == 1

        response = responses[0]
        assert response['_index'] == es_index
        assert response['_id'] == es_doc_id
        assert response['_type'] == es_mapping
        assert response['_source'] == {'text': raw_str}
    finally:
        # Clean up test data in ES
        elasticsearch.client.delete_index(es_index)


# SDC-11233: Elasticsearch origin does not properly upgrade single-threaded offsets
@elasticsearch
def test_offset_upgrade(sdc_builder, sdc_executor, elasticsearch):
    """Ensure that when upgrading from older offset format (that can be generated by either SCH or by upgrading
       pre-multithreaded pipeline) we properly upgrade the offset and the pipeline will not re-read everything
       from the source.
    """
    es_index = get_random_string(string.ascii_letters, 10).lower()
    es_doc_id = get_random_string(string.ascii_letters, 10)
    raw_str = 'Hello World!'
    raw = {'body': raw_str}

    builder = sdc_builder.get_pipeline_builder()
    es_origin = builder.add_stage('Elasticsearch', type='origin')
    es_origin.set_attributes(index=es_index, query="{'query': {'match_all': {}}}")
    wiretap = builder.add_wiretap()

    es_origin >> wiretap.destination
    pipeline = builder.build().configure_for_environment(elasticsearch)
    sdc_executor.add_pipeline(pipeline)

    # We hard code offset to be pre-migration to multi-threaded origin and thus forcing the origin to upgrade it
    offset = {
        'offsets': {
            '$com.streamsets.datacollector.pollsource.offset$': None,
        },
        'version': 2
    }
    sdc_executor.api_client.update_pipeline_committed_offsets(pipeline.id, body=offset)

    try:
        # Put data to Elasticsearch
        elasticsearch.client.create_document(es_index, es_doc_id, raw)

        # Run pipeline and assert
        sdc_executor.start_pipeline(pipeline).wait_for_finished()
        # no need to stop pipeline - as ES origin shuts off once data is read from Elasticsearch

        assert len(wiretap.output_records) == 1
        # assert ES meta
        assert wiretap.output_records[0].field['_index'] == es_index
        assert wiretap.output_records[0].field['_id'] == es_doc_id
        # assert ES data
        assert wiretap.output_records[0].field['_source']['body'] == raw_str

        # Now let's validate that the offset doesn't have the poll key any more
        offset = sdc_executor.api_client.get_pipeline_committed_offsets(pipeline.id).response.json()
        assert offset is not None
        assert '$com.streamsets.datacollector.pollsource.offset$' not in offset['offsets']
    finally:
        # Clean up test data in ES
        elasticsearch.client.delete_index(es_index)


@sdc_min_version('3.17.0')
@elasticsearch
@pytest.mark.parametrize('join_credentials', [True, False])
def test_elasticsearch_credentials_format(sdc_builder, sdc_executor, elasticsearch, join_credentials):
    """
    Elasticsearch target pipeline where specifies two different formats for the credential values.
    First, it checks if the previous format "username:password" is also valid and then update the pipeline with the new
    format, user name and password into two different fields, and checks again.
        dev_raw_data_source >> es_target
    """
    # Test static
    es_index = get_random_string(string.ascii_letters, 10).lower()  # Elasticsearch indexes must be lower case
    es_mapping = get_random_string(string.ascii_letters, 10)
    es_doc_id = get_random_string(string.ascii_letters, 10)
    raw_str = 'Hello World!'

    if join_credentials:
        username = elasticsearch.username + ':' + elasticsearch.password
        password = ''
    else:
        username = elasticsearch.username
        password = elasticsearch.password

    # Build pipeline
    builder = sdc_builder.get_pipeline_builder()
    dev_raw_data_source = builder.add_stage('Dev Raw Data Source').set_attributes(data_format='TEXT',
                                                                                  stop_after_first_batch=True,
                                                                                  raw_data=raw_str)
    es_target = builder.add_stage('Elasticsearch', type='destination')
    es_target.set_attributes(default_operation='INDEX', document_id=es_doc_id, index=es_index, mapping=es_mapping,
                             use_security=True, user_name=username, password=password)

    dev_raw_data_source >> es_target
    es_target_pipeline = builder.build().configure_for_environment(elasticsearch)
    es_target_pipeline.configuration["shouldRetry"] = False

    sdc_executor.add_pipeline(es_target_pipeline)

    try:
        elasticsearch.client.create_index(es_index)

        # Run pipeline and read credential values from Elasticsearch to assert
        sdc_executor.start_pipeline(es_target_pipeline).wait_for_finished()

        # Since we are upsert on the same index, map, doc - there should only be one document (index 0)
        response = elasticsearch.client.search(es_index)
        assert len(response) == 1
        assert response[0]['_index'] == es_index
        assert response[0]['_id'] == es_doc_id
        assert response[0]['_type'] == es_mapping
        assert response[0]['_source'] == {'text': raw_str}
    finally:
        # Clean up test data in ES
        elasticsearch.client.delete_index(es_index)


@elasticsearch
def test_index_and_template_with_plus_get_encoded(sdc_builder, sdc_executor, elasticsearch):
    """
    We want to test that we can search in documents of document types containing the '+' character
    belonging to indices containing the '+' character.
    So we will create an index with the '+' character and a document type with the '+' character.
    Then we will search for fields in all in the index. If the '+' character is accepted
    then we will get exactly the same document we created before since the newly created index
    contains only it. The pipeline is as follows:

    Elasticsearch >> Trash

    This same test should pass for all Elasticsearch versions.
    This test will fail for SDC version less than 3.19.0 which is expected.
    """

    doc_id = get_random_string(string.ascii_lowercase)
    doc_index = f'{doc_id}id+x'
    doc_type = f'{doc_id}tp+y'
    doc = {"data": "DATA"}

    client = elasticsearch.client.client
    client.create(index=doc_index, doc_type=doc_type, id=doc_id, body=doc)

    try:
        builder = sdc_builder.get_pipeline_builder()

        es = builder.add_stage('Elasticsearch', type='origin')
        es.index = doc_index
        es.mapping = doc_type
        es.query = "{'query': {'match_all': {}}}"

        wiretap = builder.add_wiretap()
        pipeline_finisher = builder.add_stage('Pipeline Finisher Executor')
        es >> [wiretap.destination, pipeline_finisher]

        pipeline = builder.build().configure_for_environment(elasticsearch)
        pipeline.configuration["shouldRetry"] = False
        sdc_executor.add_pipeline(pipeline)

        sdc_executor.start_pipeline(pipeline).wait_for_finished()
        output_data = [record.field for record in wiretap.output_records]

        assert len(output_data) == 1
        assert output_data[0]['_index'] == doc_index
        assert output_data[0]['_id'] == doc_id
        assert output_data[0]['_type'] == doc_type
        assert output_data[0]['_source'] == doc
    finally:
        elasticsearch.client.delete_index(doc_index)
